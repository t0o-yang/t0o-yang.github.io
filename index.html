<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Python语言实现KNN算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-04-06T07:58:00.591Z" itemprop="datePublished">2023-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/">python实现KNN算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="实现knn算法"><a href="#实现knn算法" class="headerlink" title="实现knn算法"></a>实现knn算法</h1><h2 id="knn算法介绍"><a href="#knn算法介绍" class="headerlink" title="knn算法介绍"></a>knn算法介绍</h2><p><strong>knn（k-NearestNeighbor），中译：k最近邻分类算法</strong>。算法要完成的事情是：一组已分类数据集，一组待分数据，根据knn算法将待分数据分好类。<br>明白要做什么，这个过程的分类准则就是knn算法。其<strong>核心</strong>就是，<strong>由近邻数据的类别决定待分数据的类别。</strong><br>那么判断是否为近邻又由什么决定呢？——距离，确切来说是，<strong>欧式距离</strong>。空间中有两个点 a(x<del>0</del>, y<del>0</del>)，b(x<del>1</del>, y<del>1</del>) ，两点之间的距离就是欧式距离。公式请自查。<br>放图说话，下图都是表示knn决策过程。</p>
<p><img src="/../images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.png" alt="knn决策过程1"></p>
<p><img src="/../images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B2.png" alt="knn决策过程2"></p>
<p>其也能进行回归分析，详细内容请参考<strong>近邻算法_百度百科</strong>，点击<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=STA-SNpUskTFahm4e40lxLoFauAOQgU2ZejmD9LERZko7zXJpW5C3PEdGUlxTOckkYhWDP8yF9xD8FoAwGvoJBEZXn_rX5hLee-0oG3Fln-UYxQBDsGNuPlpr8C6MvB0ARBLxkG6gfxCQkhCbKXX5PoutWn5P9lx9B2YraqG68_&wd=&eqid=dbdd4a310075fec5000000035da0a9be">这里</a>。</p>
<h2 id="算法步骤及实现"><a href="#算法步骤及实现" class="headerlink" title="算法步骤及实现"></a>算法步骤及实现</h2><p><strong>具体实现参考了近邻算法_百度百科</strong>，下面将算法步骤和算法实现放在一起。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据存取方式采用<strong>操作列表</strong>的方式，这里考虑的是熟练度。当然<strong>推荐选择导入 Numpy ，操作效率更高</strong>。</p>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/../images/knn%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<h3 id="1-训练集和测试集"><a href="#1-训练集和测试集" class="headerlink" title="1.训练集和测试集"></a>1.训练集和测试集</h3><p>先获取训练集数据和测试集数据，实现过程中先采用的训练集和测试集是，自编的简单数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myDataset = &#123;<span class="string">&#x27;data&#x27;</span>:[[<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">             <span class="string">&#x27;target&#x27;</span>:[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;</span><br><span class="line">X_train, y_train = myDataset[<span class="string">&#x27;data&#x27;</span>], myDataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">X_test = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>具体真正使用的训练集和测试集是，鸢尾花数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris_dataset = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_dataset[<span class="string">&#x27;data&#x27;</span>], iris_dataset[<span class="string">&#x27;target&#x27;</span>], random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-设定k值"><a href="#2-设定k值" class="headerlink" title="2.设定k值"></a>2.设定k值</h3><p>k值，是决定了待测数据 X_test 会有 k 个邻居。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_neighbors</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;指定近邻个数&#x27;&#x27;&#x27;</span></span><br><span class="line">    self.n_neighbors = n_neighbors <span class="comment"># 近邻数</span></span><br><span class="line">    <span class="comment"># self.x_new = [] # 预测数据集</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建预先序列"><a href="#3-创建预先序列" class="headerlink" title="3.创建预先序列"></a>3.创建预先序列</h3><p>百科中第四步，<strong>优先级队列</strong>在本文名为：<strong>预先序列</strong> 。预先序列其实就是近邻序列，其大小等于 k ，具体说是，预先序列计算处理得到的距离的预先序列 <strong>distList</strong> 。关于创建预先序列的用途，我的理解是，<strong>当 k &gt; 1时，即待分数据会有 k 个邻居时，在不采用预先序列的情况下，同样的，会产生一个 k 大小的近邻序列，并且在生成序列过程中第 i ( i &lt; k ) 个数据都需要进行判断数据是否需要更新。而采用了预先序列，每次比大小的两方，一个是训练数据集，另一个就会变成 distList 中的最大值，更新最大值即可，会减少判断次数。</strong><br><code>使用每个数据的ID(索引)建立预先序列</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.idList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x_train)), self.n_neighbors) <span class="comment"># 获取空间大小为k的预先序列,k个随机的元组,k=n_neighbors</span></span><br></pre></td></tr></table></figure>

<p><code>计算距离</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_deftDist</span>(<span class="params">self, tp</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算测试数据与预先序列的距离&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">list</span> = [] <span class="comment"># 存放预测数据与预先序列的距离，列表含有k个距离</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    for i in range(len(self.x_new)):</span></span><br><span class="line"><span class="string">        tp = self.x_new[i]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        index = self.idList[j]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tp)):</span><br><span class="line">            <span class="built_in">sum</span> += (tp[k]-self.x_train[index][k])**<span class="number">2</span> </span><br><span class="line">        <span class="built_in">sum</span> = math.sqrt(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="built_in">list</span>.append(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h3 id="4-更新预先序列"><a href="#4-更新预先序列" class="headerlink" title="4.更新预先序列"></a>4.更新预先序列</h3><p>遍历训练集，计算当前训练集数据 X_train<del>i</del> 与待分数据 X_test<del>j</del> 的距离 L ，比较 L 与预先的最大距离 LMax 大小，若大于，直接进入下一训练集数据 X_train<del>i+1</del> ，若小于，将 LMax 对应的序列数据替换成 X_train<del>i</del> 。<br><strong>在需要替换时，其实还需要一步判断，在构建预先序列时，K个随机值构成的 idList 可能已经包含了当前训练集数据 X_train_i 的索引值即 i ，所以如果替换元素的话，近邻队列不就出现1或多个重复的元素了吗？，那么分类应该会有误差</strong>。参考百科中的第 6 步，似乎没有考虑到。<br><code>解决上文提到的 “ 判断 ” </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">    index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">    self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">    distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br></pre></td></tr></table></figure>

<p><code>算法当前步骤所有代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">distList = self.get_deftDist(tp) <span class="comment"># 获取此时测试数据x_new[i]与预先序列的距离</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train)):</span><br><span class="line">    Lmax = <span class="built_in">max</span>(distList)</span><br><span class="line">    L = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train[j])):</span><br><span class="line">        L += (tp[k]-self.x_train[j][k])**<span class="number">2</span> <span class="comment"># 遍历训练集，计算当前x_new[i]训练集与x_train[j]的距离</span></span><br><span class="line">    L = math.sqrt(L)</span><br><span class="line">    <span class="keyword">if</span> L &gt;= Lmax:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 若当前所得距离大于预先序列距离的最大值，进入下一个训练数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 更新预先序列中的距离和对应训练数据的id</span></span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">            index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">            self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">            distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br></pre></td></tr></table></figure>

<h3 id="5-获取测试集所属类"><a href="#5-获取测试集所属类" class="headerlink" title="5.获取测试集所属类"></a>5.获取测试集所属类</h3><p>遍历最后的近邻序列，选择出其中多数类，得出测试数据集的所需类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)): <span class="comment"># 遍历预先序列中，计算其中的多数类，判断测试数据属于哪类</span></span><br><span class="line">        indI = self.idList[m]</span><br><span class="line">        targetI = self.y_train[indI]</span><br><span class="line">        <span class="keyword">if</span> targetI == <span class="number">0</span>:</span><br><span class="line">            flag[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> targetI == <span class="number">1</span>:</span><br><span class="line">            flag[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> targetI == <span class="number">2</span>:</span><br><span class="line">            flag[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">        <span class="comment">#print(flag)</span></span><br><span class="line">    <span class="comment">#print(&#x27;测试数据所属类: &#x27;, flag.index(max(flag)))</span></span><br><span class="line">    targetList.append(flag.index(<span class="built_in">max</span>(flag))) <span class="comment"># 返回第一个极大值的索引值</span></span><br></pre></td></tr></table></figure>

<h3 id="预测模型的精准度"><a href="#预测模型的精准度" class="headerlink" title="预测模型的精准度"></a>预测模型的精准度</h3><p>除了上述knn算法的五个步骤外，还额外添加了计算模型的精确值的方法 score() 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, y_pre, y_test</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算精确值&#x27;&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    scoreList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>], <span class="built_in">zip</span>(y_pre, y_test)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> scoreList:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    score = count/<span class="built_in">len</span>(scoreList)</span><br><span class="line">    <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>算法结构是<strong>仿照 KNeighborsClassifier</strong>的使用过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">31</span>) <span class="comment">#设定近邻指标</span></span><br><span class="line"></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pre = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">score = knn.score(X_test, y_test)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>KNeighborsClassifier</th>
<th>MyKNN</th>
<th>MykNN的方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>–init–()</td>
<td>–init–()</td>
<td>设定近邻个数</td>
</tr>
<tr>
<td>fit()</td>
<td>get_trainData()</td>
<td>获取训练集数据</td>
</tr>
<tr>
<td>predict()</td>
<td>predict()</td>
<td>产生预测模型</td>
</tr>
<tr>
<td>score()</td>
<td>score()</td>
<td>计算精确度</td>
</tr>
</tbody></table>
<p><code>完整knn代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyKNN</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_neighbors</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;指定近邻个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.n_neighbors = n_neighbors <span class="comment"># 近邻数</span></span><br><span class="line">        <span class="comment"># self.x_new = [] # 预测数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x_new</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;预测模型, 更新近邻序列和得出测试数据所属类&#x27;&#x27;&#x27;</span></span><br><span class="line">        targetList = [] <span class="comment"># 存储预测数据的预测所属类</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_new)):</span><br><span class="line">            tp = x_new[i]</span><br><span class="line">            <span class="comment">#print(tp)</span></span><br><span class="line">            distList = self.get_deftDist(tp) <span class="comment"># 获取此时测试数据x_new[i]与预先序列的距离</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train)):</span><br><span class="line">                Lmax = <span class="built_in">max</span>(distList)</span><br><span class="line">                L = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train[j])):</span><br><span class="line">                    L += (tp[k]-self.x_train[j][k])**<span class="number">2</span> <span class="comment"># 遍历训练集，计算当前x_new[i]训练集与x_train[j]的距离</span></span><br><span class="line">                L = math.sqrt(L)</span><br><span class="line">                <span class="keyword">if</span> L &gt;= Lmax:</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># 若当前所得距离大于预先序列距离的最大值，进入下一个训练数据</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 更新预先序列中的距离和对应训练数据的id</span></span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">                        index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">                        self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">                        distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br><span class="line">                <span class="comment">#distList[i].append(L)</span></span><br><span class="line">        <span class="comment">#return sorted(distList)</span></span><br><span class="line">            flag = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)): <span class="comment"># 遍历预先序列中，计算其中的多数类，判断测试数据属于哪类</span></span><br><span class="line">                indI = self.idList[m]</span><br><span class="line">                targetI = self.y_train[indI]</span><br><span class="line">                <span class="keyword">if</span> targetI == <span class="number">0</span>:</span><br><span class="line">                    flag[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> targetI == <span class="number">1</span>:</span><br><span class="line">                    flag[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> targetI == <span class="number">2</span>:</span><br><span class="line">                    flag[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment">#print(flag)</span></span><br><span class="line">            <span class="comment">#print(&#x27;测试数据所属类: &#x27;, flag.index(max(flag)))</span></span><br><span class="line">            targetList.append(flag.index(<span class="built_in">max</span>(flag))) <span class="comment"># 返回第一个极大值的索引值</span></span><br><span class="line">            <span class="comment">#print(&#x27;the distance:\n&#123;&#125;&#x27;.format(self.distList))</span></span><br><span class="line">        <span class="keyword">return</span> targetList</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_trainData</span>(<span class="params">self, x_train, y_train</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取训练集数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.x_train = x_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line">        self.idList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x_train)), self.n_neighbors) <span class="string">&#x27;&#x27;&#x27; 获取空间大小为k的预先序列,k个随机的元             </span></span><br><span class="line"><span class="string">        组,k=n_neighbors&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#self.deftDic = &#123;&#x27;id&#x27;:self.idList, &#x27;distance&#x27;:self.distList, &#x27;target&#x27;:self.y_train&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_deftDist</span>(<span class="params">self, tp</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;计算测试数据与预先序列的距离&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">list</span> = [] <span class="comment"># 存放预测数据与预先序列的距离，列表含有k个距离</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        for i in range(len(self.x_new)):</span></span><br><span class="line"><span class="string">            tp = self.x_new[i]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            index = self.idList[j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tp)):</span><br><span class="line">                <span class="built_in">sum</span> += (tp[k]-self.x_train[index][k])**<span class="number">2</span> </span><br><span class="line">            <span class="built_in">sum</span> = math.sqrt(<span class="built_in">sum</span>)</span><br><span class="line">            <span class="built_in">list</span>.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, y_pre, y_test</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;计算精确值&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        scoreList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>], <span class="built_in">zip</span>(y_pre, y_test)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> scoreList:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        score = count/<span class="built_in">len</span>(scoreList)</span><br><span class="line">        <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"><span class="comment">#myDataset = &#123;&#x27;data&#x27;:[[2, 3, 0, 0], [3, 4, 0, 0], [4, 5, 0, 0], [5, 6, 0, 0]],</span></span><br><span class="line"><span class="comment">#             &#x27;target&#x27;:[2, 1, 0, 1]&#125;</span></span><br><span class="line"><span class="comment">#X_train, y_train = myDataset[&#x27;data&#x27;], myDataset[&#x27;target&#x27;]</span></span><br><span class="line"><span class="comment">#X_test = [[1, 2, 0, 0],[0, 0, 0, 0]]</span></span><br><span class="line"></span><br><span class="line">iris_dataset = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_dataset[<span class="string">&#x27;data&#x27;</span>], iris_dataset[<span class="string">&#x27;target&#x27;</span>], random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()      </span><br><span class="line"></span><br><span class="line">knn = MyKNN(n_neighbors=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">knn.get_trainData(X_train, y_train)</span><br><span class="line">y_pre = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Holding time: &#x27;</span>, time.time()-start) <span class="comment"># 输出KNN运行时间，时间效率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the kind of X_test:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(y_pre)) <span class="comment"># 输出测试数据的预测类别</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the score:&#123;:.2&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(y_pre, y_test))) <span class="comment"># 输出模型精准度</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/" data-id="clg4u0zfm0003ogaaakst6cvx" data-title="python实现KNN算法" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-前端八股文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/22/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2023-03-22T13:42:24.862Z" itemprop="datePublished">2023-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/22/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/">前端八股文</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h2><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>让人更容易读懂，代码可读性；<br>让搜索引擎更容易读懂，SEO；<br>tod，常见的语义化标签</p>
<h3 id="块状元素-amp-内联元素"><a href="#块状元素-amp-内联元素" class="headerlink" title="块状元素 &amp; 内联元素"></a>块状元素 &amp; 内联元素</h3><p>块级元素 display&#x3D;block&#x2F;table，有 div,h,table,ul,ol,p;<br>内联元素 display&#x3D;inline&#x2F;line&#x3D;block，有 span,img,input,button,a;</p>
<h3 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h3><h4 id="盒模型计算"><a href="#盒模型计算" class="headerlink" title="盒模型计算"></a>盒模型计算</h4><p>offsetWidth&#x3D;内容宽度+padding+border</p>
<h4 id="margin纵向重叠（边距塌陷）"><a href="#margin纵向重叠（边距塌陷）" class="headerlink" title="margin纵向重叠（边距塌陷）"></a>margin纵向重叠（边距塌陷）</h4><p>空元素margin值会忽略，两值取大者</p>
<h4 id="margin负值问题"><a href="#margin负值问题" class="headerlink" title="margin负值问题"></a>margin负值问题</h4><p>margin-top,left 负值，元素上移，左移<br>margin-right 负值，右侧元素左移，自身不受影响<br>margin-bottom 负值，下方元素上移，自身不受影响</p>
<h4 id="BFC的理解和应用"><a href="#BFC的理解和应用" class="headerlink" title="BFC的理解和应用"></a>BFC的理解和应用</h4><p>block format context 块级格式化上下文</p>
<ul>
<li><p>一块独立的渲染区域，内部元素的渲染不会影响边界之外的元素</p>
</li>
<li><p>形成条件：</p>
<ul>
<li>float不是none；</li>
<li>position是absolute或fixed；</li>
<li>overflow不是visible；</li>
<li>display是flex, inline-block等；</li>
</ul>
</li>
<li><p>常见应用</p>
<ul>
<li>清除浮动</li>
</ul>
</li>
</ul>
<h4 id="float应用-圣杯布局和双飞翼布局"><a href="#float应用-圣杯布局和双飞翼布局" class="headerlink" title="float应用-圣杯布局和双飞翼布局"></a>float应用-圣杯布局和双飞翼布局</h4><p>圣杯布局、双飞翼布局是PC端的布局方案</p>
<p>技术总结：</p>
<ul>
<li>使用float布局</li>
<li>两侧使用margin负值，以便和中间内容横向重叠</li>
<li>通过padding或margin为两侧留白</li>
</ul>
<p>圣杯布局实现细节：通过padding留白，左侧再设置 position：relative、right 移动位置；<br>双飞翼布局实现细节：中间栏需要再嵌套一层 div</p>
<h4 id="手写clearfix"><a href="#手写clearfix" class="headerlink" title="手写clearfix"></a>手写clearfix</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JS-ES6"><a href="#JS-ES6" class="headerlink" title="JS ES6"></a>JS ES6</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>网上关于 JS 数据类型的说法不一致，我按照 MDN 文档<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Language_Overview#%E6%A6%82%E8%A7%88">介绍</a>和 typeof 的返回值为标准吧。</p>
<p>常规就是八种，</p>
<ul>
<li>Number 数字</li>
<li>String 字符串</li>
<li>Boolean 布尔</li>
<li>Symbol 符号</li>
<li>Object 对象</li>
<li>Function 函数</li>
<li>null 空</li>
<li>undefined 未定义<br>分两大类，基本类型和引用类型，引用类型：Object、Function，其余都是基本类型。<br>还有说是九种的，加上 bigint。这也是基本类型。</li>
<li>BigInt 大数<br>补充，Object 中又细分了：Array，Date, RegExp。严格上，Function 也是 Object，但是一般还是把函数单独作为一类。</li>
</ul>
<h3 id="JS-中的数据类型检测方案"><a href="#JS-中的数据类型检测方案" class="headerlink" title="JS 中的数据类型检测方案"></a>JS 中的数据类型检测方案</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;mc&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>()); <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1n</span>); <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> /d+<span class="regexp">/); /</span><span class="regexp">/ object</span></span><br></pre></td></tr></table></figure>

<p>优点：能够快速区分基本数据类型</p>
<p>缺点：不能将 Object、Array 和 Null 区分，都返回 object</p>
<h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str&quot;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1n</span> <span class="keyword">instanceof</span> <span class="title class_">BigInt</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>() <span class="keyword">instanceof</span> <span class="title class_">Symbol</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/d+/</span> <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：能够区分 Array、Object 和 Function，适合用于判断自定义的类实例对象</p>
<p>缺点：Number，Boolean，String 基本数据类型不能判断</p>
<p>注，null 和 undefined 会报错<code>TypeError</code>，<code>instanceof</code>右侧必须是个对象</p>
<h4 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3.Object.prototype.toString.call()"></a>3.Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="number">1</span>));               <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">true</span>));            <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="string">&#x27;mc&#x27;</span>));            <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="title class_">Symbol</span>());         <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="number">1n</span>));              <span class="comment">//[object BigInt]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>([]));              <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(&#123;&#125;));              <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));      <span class="comment">//[object Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="regexp">/d+/</span>));            <span class="comment">//[object RegExp]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));    <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">undefined</span>));       <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">null</span>));            <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure>

<p>优点：精准判断数据类型</p>
<p>缺点：写法繁琐不容易记，推荐进行封装后使用</p>
<p>注，这种方式深究的话，是不可靠的；可以通过定义  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag"><code>Symbol.toStringTag</code></a>  属性来更改  <code>Object.prototype.toString()</code>  的行为，从而导致意想不到的结果。但是这种判断类型方式完全够用了，有人会改这个属性？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">myDate[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&quot;myDate&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(myDate); <span class="comment">// &#x27;[object myDate]&#x27;</span></span><br><span class="line">myDate <span class="keyword">instanceof</span> <span class="title class_">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#%E7%A4%BA%E4%BE%8B">Object.prototype.toString</a></p>
<h4 id="instanceof-的作用"><a href="#instanceof-的作用" class="headerlink" title="instanceof 的作用"></a>instanceof 的作用</h4><p>用于判断一个引用类型是否属于某构造函数；</p>
<p>还可以在继承关系中用来判断一个实例是否属于它的父类型。</p>
<h4 id="instanceof-和-typeof-的区别："><a href="#instanceof-和-typeof-的区别：" class="headerlink" title="instanceof 和 typeof 的区别："></a>instanceof 和 typeof 的区别：</h4><p>typeof 在对值类型 number、string、boolean 、null 、 undefined、 以及引用类型的 function 的反应是精准的；但是，对于对象{ } 、数组[ ] 、null 都会返回 object</p>
<p>为了弥补这一点，instanceof 从原型的角度，来判断某引用属于哪个构造函数，从而判定它的数据类型。</p>
<h4 id="严格判断类型"><a href="#严格判断类型" class="headerlink" title="严格判断类型"></a>严格判断类型</h4><p>如果有需要的严格判断类型的要求，可以结合<code>typeof</code>和<code>instanceof</code>，封装一个自定义方法。参考下面代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> baseType = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="comment">// 基本类型</span></span><br><span class="line">  <span class="keyword">if</span> (![<span class="string">&quot;object&quot;</span>, <span class="string">&quot;function&quot;</span>].<span class="title function_">includes</span>(baseType)) &#123;</span><br><span class="line">    <span class="keyword">return</span> baseType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Symbol.toStringTag 通常指定对象类的“display name”</span></span><br><span class="line">  <span class="comment">// 它在 Object.prototype.toString() 中使用。</span></span><br><span class="line">  <span class="keyword">const</span> tag = value[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>];</span><br><span class="line">  <span class="comment">// 构造函数的名称；例如 `Array`、`GeneratorFunction`、`Number`、`String`、`Boolean` 或 `MyCustomClass`</span></span><br><span class="line">  <span class="keyword">const</span> className = value.<span class="property">constructor</span>.<span class="property">name</span>;</span><br><span class="line">  <span class="comment">// 当构造函数与 display name 不一致时，以构造函数优先</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&quot;string&quot;</span> &amp;&amp; tag === className) &#123;</span><br><span class="line">    <span class="keyword">return</span> tag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果它是一个函数，其源代码以 &quot;class&quot; 关键字开头</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    baseType === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value).<span class="title function_">startsWith</span>(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> className === <span class="string">&quot;string&quot;</span> &amp;&amp; className !== <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> className;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这一点上，没有合适的方法来获取值的类型，因此我们使用基本实现。</span></span><br><span class="line">  <span class="keyword">return</span> baseType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以避免随意通过<code>Symbol.toStringTag</code>修改类。但是就不能使用自定义类名了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MClass&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cls = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">type</span>(cls)); <span class="comment">// C</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(cls)); <span class="comment">// [object MClass]</span></span><br></pre></td></tr></table></figure>

<h3 id="var、let-和-const"><a href="#var、let-和-const" class="headerlink" title="var、let 和 const"></a>var、let 和 const</h3><p>var、let、const 都是声明变量的关键词，主要区别是</p>
<ol>
<li><p>变量提升，var 声明的变量会出现变量提升的情况，即可以在声明前使用变量；let 和 const 声明前使用会报错；</p>
</li>
<li><p>暂时性死区，var 不存在，let 和 const 存在，在声明语句之前，不能获取和设置变量；</p>
</li>
<li><p>作用域不同，let 和 const 作用于块级作用域，var 作用于函数作用域；</p>
</li>
<li><p>重新赋值，const 声明的是一个常量，值不能改变。let，var 可以；</p>
</li>
<li><p>重复声明，let 和 const 在同一作用域内不能重复声明，var 不限制；</p>
</li>
</ol>
<h3 id="作用域、作用域链"><a href="#作用域、作用域链" class="headerlink" title="作用域、作用域链"></a>作用域、作用域链</h3><p><strong>作用域</strong>指变量和函数能够被访问的区域，作用域可分为：</p>
<ul>
<li>全局作用域，在函数和大括号之外声明的变量，都在全局作用域下，可以在程序的任意位置访问；</li>
<li>函数作用域，在函数内声明的变量，只能在函数内部访问；</li>
<li>块级作用域，在大括号内使用<code>let</code>和<code>const</code>声明的变量，只存在于块级作用域内，在大括号外不能访问；</li>
</ul>
<p><strong>作用域链</strong>：在 JS 中使用变量时，首先 JS 引擎会在当前作用域中寻找该变量，如果没找到，会到其上层作用域寻找，直至变量找到或到了全局作用域。如果在全局作用域内没有找到，会隐式声明该变量（非严格模式下，返回 undefined）或直接报错。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包</strong>指一个函数和对其周围状态的引用捆绑在一起，即闭包让内层函数可以访问到外层函数的作用域。<br>闭包的使用场景：保存变量（延长变量的生命周期）；保护变量（创建私有化变量）。例子，柯里化函数</p>
<h3 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h3><p>this 对象是函数运行时自动生成的一个内部对象，只能在函数内使用。它始终指向调用这个函数的对象。在不同的使用场合下，this 有不同的值，大致可以分为以下 4 种：</p>
<ul>
<li>默认绑定，普通函数调用，this 指向<code>window</code>；</li>
<li>隐式绑定，函数作为对象的方法被调用，this 指向这个对象；</li>
<li>new 绑定，作为构造函数调用，new 会返回一个实例对象，this 指向这个实例对象，特殊情况<ul>
<li>遇到函数返回一个对象，则 this 指向返回的对象</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回一个简单类型的数据，则 this 还是指向实例对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显式绑定，使用<code>call</code>、<code>apply</code>、<code>bind</code>可以显式改变函数的 this 指向</li>
<li>箭头函数的 this，箭头函数没有自己的 this 指向，它的 this 指向上一级作用域的 this</li>
</ul>
<h3 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h3><ul>
<li>三者都是显式改变函数中的 this 指向。</li>
<li>第一个参数就是指向的对象，如果参数为空或是 null、undefined，则默认指向 window</li>
<li>都可以传参，但 call 接收的是参数序列，apply 接收数组，而且 call 和 apply 都是一次性传入，bind 可以分多次传入</li>
<li>bind 是返回绑定 this 之后的函数，而 call 和 apply 是立即执行</li>
</ul>
<h4 id="实现-bind"><a href="#实现-bind" class="headerlink" title="实现 bind"></a>实现 bind</h4><p>IE8 及以下不支持 bind，所以可能会问这个问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>,</span><br><span class="line">    args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">self</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)) : context,</span><br><span class="line">      args.<span class="title function_">concat</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h3><p>‌ <strong>原型:</strong>   在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code>  属性，这个属性指向函数的<code>原型对象</code>。<br>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链</strong>。下面总结：</p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 <code>__proto__</code></li>
<li>实例的 <code>__proto__</code> 指向对应 class 的 prototype</li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol>
<li>首先创建了一个新的空对象</li>
<li>设置原型，将对象的原型设置为函数的 prototype 对象。</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<h4 id="实现-new"><a href="#实现-new" class="headerlink" title="实现 new"></a>实现 new</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.<span class="property">__proto__</span> = func.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">let</span> result = func.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="eventloop-事件循环机制"><a href="#eventloop-事件循环机制" class="headerlink" title="eventloop 事件循环机制"></a>eventloop 事件循环机制</h3><p><code>JS</code>是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code>，宏任务的话就是<code>setImmediate setTimeout setInterval</code></p>
<p>JS 运行的环境。一般为浏览器或者 Node。 在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<h4 id="浏览器中的事件环（Event-Loop）"><a href="#浏览器中的事件环（Event-Loop）" class="headerlink" title="浏览器中的事件环（Event Loop）"></a>浏览器中的事件环（Event Loop）</h4><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p>
<ul>
<li><p>eventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p>
</li>
<li><p>事件循环可以简单的描述为以下四个步骤:</p>
<ol>
<li>函数入栈，当 Stack 中执行到异步任务的时候，就将他丢给 WebAPIs,接着执行同步任务,直到 Stack 为空；</li>
<li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li>
<li>执行栈为空时，Event Loop 把微任务队列执行清空；</li>
<li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入 Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复 4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-1.image" alt="事件循环流程"></p>
</li>
<li><p>浏览器中的任务源(task):</p>
<ul>
<li><code>宏任务(macrotask)</code>：<br>宿主环境提供的，比如浏览器<br>ajax、setTimeout、setInterval、setTmmediate(只兼容 ie)、script、requestAnimationFrame、messageChannel、UI 渲染、一些浏览器 api</li>
<li><code>微任务(microtask)</code>：<br>语言本身提供的，比如 promise.then<br>then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li>
</ul>
</li>
</ul>
<p>传送门 ☞ <a target="_blank" rel="noopener" href="https://juejin.cn/post/7001881781125251086"># 宏任务和微任务</a></p>
<h4 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a>Node 环境中的事件环（Event Loop)</h4><p><code>Node</code>是基于 V8 引擎的运行在服务端的<code>JavaScript</code>运行环境，在处理高并发、I&#x2F;O 密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是 V8 引擎，但由于服务目的和环境不同，导致了它的 API 与原生 JS 有些区别，其 Event Loop 还要处理一些 I&#x2F;O，比如新的网络连接等，所以 Node 的 Event Loop(事件环机制)与浏览器的是不太一样。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-1.image" alt="2020120317343116.png"> 执行顺序如下：</p>
<ul>
<li><code>timers</code>: 计时器，执行 setTimeout 和 setInterval 的回调</li>
<li><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调</li>
<li><code>idle, prepare</code>: 队列的移动，仅系统内部使用</li>
<li><code>poll轮询</code>: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li>
<li><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate 在这里执行</li>
<li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commitment</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;待定&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;拒绝&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span> = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">func</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(result);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(result);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFULFILLED, onREJECTED</span>) &#123;</span><br><span class="line">    onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&quot;function&quot;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&quot;function&quot;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">push</span>(onFULFILLED);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span>.<span class="title function_">push</span>(onREJECTED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onFULFILLED</span>(<span class="variable language_">this</span>.<span class="property">result</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">REJECTED</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onREJECTED</span>(<span class="variable language_">this</span>.<span class="property">result</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流防抖"><a href="#节流防抖" class="headerlink" title="节流防抖"></a>节流防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">//记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//清除上一次的演示器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="comment">//重新设置新的延时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//修正this指向问题</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">//记录上一次函数触发的时间</span></span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//记录当前函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">      <span class="comment">//修正this指向问题</span></span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="comment">//同步执行结束时间</span></span><br><span class="line">      lastTime = nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><ul>
<li><p>数组基本操作有，push\unshift\concat,用于数组添加；pop\shift\slice,用于数组删除；splice 用于修改数组；indexOf 用于查找数组，es6 中增加了 find、includes；</p>
</li>
<li><p>用于排序的方法，有 reverse、sort</p>
</li>
<li><p>用于数组的转换有 join ，将数组转变为字符串，参数是字符串分割符</p>
</li>
<li><p>遍历相关的方法有 some、every、foreach、filter、map、 reduce</p>
</li>
</ul>
<p>方法细节：</p>
<p>push：接收多个参数，并添加到目标数组的末尾，返回数组最新长度</p>
<p>unshift: 接收多个参数，并添加到目标数组的开头，返回数组最新长度</p>
<p>concat: 将目标数组和参数合并到一个数组中，返回一个新数组，<strong>不改变原数组</strong></p>
<p>pop：删除数组最后一个成员，返回删除的项</p>
<p>shift：删除数组第一项，返回删除的项</p>
<p>slice：获取数组的部分，并将其返回，<strong>不改变原数组</strong></p>
<p>splice：删除数组的一部分元素，并在删除的位置上添加新的元素。splice(start,0,item),在 start 位置前添加 item ；splice(0,delCount) 删除 delCount 个数组成员，返回被删除的元素。</p>
<p>indexOf: 返回给定元素在数组中第一次出现的位置，如果没有返回 -1，不能找 NaN</p>
<p>find：找到第一个符合条件的数组成员，如果没有返回 undefined，参数是一个回调函数，所有成员依次执行该函数，直到找到第一个返回值为 true 的成员</p>
<p>includes： 判断数组中是否包含给定的一个值，false 和 0 不相等，使用零值相等算法确定是否找到元素</p>
<p>区别：indexOf 不能找 NaN，find，includes 可以</p>
<p>sort：对数组排序，默认按照字典顺序排序</p>
<p>reverse：颠倒数组排序，返回改变后的数组</p>
<p>join：已给定的分隔符，将数组成员连成字符串返回，默认用逗号。undefined、null 和空位都会变换成空字符串</p>
<p>some、every： 判断数组成员是否满足某个条件，some 只要一个成员返回值为 true 则 some 返回 true；every 则需要所有成员返回 true。空数组 some 返回 false ，every 返回 true</p>
<p>forEach，map：对所有成员执行参数函数，forEach 没有返回值，map 有，<strong>不改变原数组</strong></p>
<p>filter：对所有成员执行参数函数，过滤出返回值为 true 的数组成员，返回一个新数组，<strong>不改变原数组</strong></p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><ol>
<li><p><code>...</code>扩展运算符，可将数组变成逗号分割的参数序列，常用于函数调用</p>
</li>
<li><p>新增两个创建数组的方法：Array.from()将类数组对象和可遍历对象转化为真正的数组，，Array.of()类似 Array 构造函数的功能，但是参数个数不同不会有不同结果</p>
</li>
<li><p>新增的实例对象方法</p>
<ol>
<li><p>遍历：keys, values, entries。这也是对象的遍历方式，因为数组是个特殊的对象，所以能用</p>
</li>
<li><p>查找：find 返回数组中第一个满足条件的成员, findIndex 返回数组中第一个满足条件的成员的位置，includes 判断是否包含给定值</p>
</li>
<li><p>修改: copyWithin 在当前数组内部将指定位置的成员复制到其他位置, fill 使用给定值填充一个数组</p>
</li>
<li><p>转化： flat 展开嵌套的数组，返回一个新数组， flatMap 对数组的每个成员执行一个函数，然后对返回值组成的数组执行 flat 方法，只展开一层</p>
</li>
</ol>
</li>
</ol>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><ol>
<li><p>属性简写，可以将变量和函数名直接写在大括号内，作为对象的属性和方法</p>
</li>
<li><p>属性名表达式，在中括号内写表达式，在 es6 中允许在用字面量定义对象时，用表达式的形式表示属性名</p>
</li>
<li><p><code>...</code> 对象的扩展运算符，取出参数对象的所有可遍历属性，拷贝到当前对象中，常用于复制对象</p>
</li>
<li><p>super 关键词，指向当前对象的原型对象</p>
</li>
<li><p>遍历对象的属性</p>
<ol>
<li><p>for…in 遍历自身和继承的的可枚举</p>
</li>
<li><p>keys 自身的可枚举的，不含继承的</p>
</li>
<li><p>getOwnPropertyNames 自身所有属性，含不可枚举的</p>
</li>
<li><p>getOwnPropertySymbols 自身的所有 Symbols 属性的键名</p>
</li>
<li><p>Reflect.ownKeys 自身所有键名（不论 symbols 还是 可枚举），不含继承的</p>
</li>
</ol>
<p>遍历对象的键名，都遵守同样的属性遍历的次序规则：首先遍历数值键，按照数值升序；其次遍历字符串键，按加入时间升序；最后遍历 symbols 键，按加入时间升序</p>
</li>
<li><p>对象新增的方法：</p>
<ol>
<li><p>遍历：Object.keys, Object.values, Object.entries</p>
</li>
<li><p>改：Object.assign 合并对象，将源对象合并到目标对象，浅拷贝</p>
</li>
<li><p>转化：Object.fromEntries entries 的逆操作，将键值对数组转化成对象</p>
</li>
<li><p>Object.is 对比方法，相对于 &#x3D;&#x3D;&#x3D; ,区别是 is 中，+0 不等于-0，NaN 等于 NaN。&#x3D;&#x3D;&#x3D; 相反</p>
</li>
<li><p>Object.setPrototypeOf 设置原型，Object.getPrototypeOf 获取原型。Object.getOwnPropertyDescriptors 获取自身属性描述</p>
</li>
</ol>
</li>
</ol>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>一种”编程范式”（programming paradigm），一种编写程序的方法论。它倡导利用简单的执行单元使计算结果不断渐进，最终完成复杂的任务。函数式编程旨在尽可能的提高代码的无状态性和不变性。简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。<br>编程范式主要有三种：命令式编程、声明式编程，以及函数式编程。</p>
<ul>
<li><p>与命令式的区别：它关注执行结果，命令式更强调执行过程。</p>
</li>
<li><p>与声明式的区别：它并不需要进一步抽象封装成类（声明式编程，我理解就是多了类）。</p>
</li>
<li><p>优点：</p>
<ul>
<li>更简单的复用，不用考虑内部变化和外部影响</li>
<li>更好的管理状态，提倡无状态，或者说更少的状态，能更大程度的减少未知情况，减少意外错误。</li>
<li>代码可组合</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能开销，对方法的过度包装，从而产生上下文切换的性能开销。</li>
<li>资源占用，为了实现对象状态的不可变，往往会创建新的对象。</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作，会造成性能开销。为了优化，我们往往需要写成<strong>尾递归</strong>形式。</li>
</ul>
</li>
</ul>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>给定的输入参数，会返回相同的结果，并且所有的数据是不可变的。纯函数&#x3D;无状态+数据不可变。</p>
<h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><p>执行了与返回值无关的事件，如修改了全局变量，修改了传入的参数，发送请求（useEffect）等等。即数据不可变。</p>
<h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p>日常前端开发三种都会使用，以命令式为主，当需要提高代码的复用性，减少重复的时候，会将一些代码抽离成函数。声明式编程会少一些，因为前端对类的使用会少一些。近些前端框架都开始强调函数式编程，大势所趋。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>Model-View-ViewModel 的缩写，Model 表示数据模型，View 表示 UI 组件，ViewModel 表示同步 view 和 model 的对象，数据绑定到 viewmodel 层并且自动渲染到页面中，当视图变化时会通知 viewmodel 更新数据，也就是数据驱动视图。优点：</p>
<ul>
<li>低耦合，view 可以独立于 model 变化，一个 model 可以绑定到多个 view 中；</li>
<li>可复用性，可以将一些视图逻辑放在 Model 中，让其他视图复用这部分视图逻辑。</li>
</ul>
<h3 id="Vue-数据绑定"><a href="#Vue-数据绑定" class="headerlink" title="Vue 数据绑定"></a>Vue 数据绑定</h3><h4 id="vue2-数据双向绑定"><a href="#vue2-数据双向绑定" class="headerlink" title="vue2 数据双向绑定"></a>vue2 数据双向绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 vue2 的数据双向绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">obj_instance</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = obj_instance.<span class="property">data</span>;</span><br><span class="line">    <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="title class_">Compile</span>(obj_instance.<span class="property">el</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持 - 监听实例中的数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params">data_instance</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data_instance || <span class="keyword">typeof</span> data_instance !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> dependency = <span class="keyword">new</span> <span class="title class_">Dependency</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data_instance).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = data_instance[key];</span><br><span class="line">    <span class="title class_">Observer</span>(value);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data_instance, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 订阅者加入依赖案例的数组</span></span><br><span class="line">        <span class="title class_">Dependency</span>.<span class="property">temp</span> &amp;&amp; dependency.<span class="title function_">addSub</span>(<span class="title class_">Dependency</span>.<span class="property">temp</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="title class_">Observer</span>(newValue);</span><br><span class="line">        dependency.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 模板解析 - 替换DOM</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Compile</span>(<span class="params">element, vm</span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(element);</span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> ((child = vm.<span class="property">$el</span>.<span class="property">firstChild</span>)) &#123;</span><br><span class="line">    fragment.<span class="title function_">append</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fragment_compile</span>(fragment);</span><br><span class="line">  <span class="comment">// 替换 文本内容</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fragment_compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/\&#123;\&#123;\s*(\S+)\s*\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> xxx = node.<span class="property">nodeValue</span>;</span><br><span class="line">      <span class="keyword">const</span> result_regex = pattern.<span class="title function_">exec</span>(node.<span class="property">nodeValue</span>);</span><br><span class="line">      <span class="keyword">if</span> (result_regex) &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = result_regex[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> value = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">        node.<span class="property">nodeValue</span> = xxx.<span class="title function_">replace</span>(pattern, value);</span><br><span class="line">        <span class="comment">// 创建订阅者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, result_regex[<span class="number">1</span>], <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">          node.<span class="property">nodeValue</span> = xxx.<span class="title function_">replace</span>(pattern, newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; node.<span class="property">nodeName</span> === <span class="string">&quot;INPUT&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> attr = <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">attributes</span>);</span><br><span class="line">      attr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.<span class="property">nodeName</span> === <span class="string">&quot;v-model&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = i.<span class="property">nodeValue</span></span><br><span class="line">            .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">          node.<span class="property">value</span> = value;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, i.<span class="property">nodeValue</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">            node.<span class="property">value</span> = newValue;</span><br><span class="line">          &#125;);</span><br><span class="line">          node.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;,&#x27;like&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr1 = i.<span class="property">nodeValue</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr2 = arr1.<span class="title function_">slice</span>(<span class="number">0</span>, arr1.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// vm.$data.more</span></span><br><span class="line">            <span class="keyword">const</span> final = arr2.<span class="title function_">reduce</span>(</span><br><span class="line">              <span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current],</span><br><span class="line">              vm.<span class="property">$data</span></span><br><span class="line">            );</span><br><span class="line">            final[arr1[arr1.<span class="property">length</span> - <span class="number">1</span>]] = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fragment_compile</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="property">$el</span>.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖 - 收集和通知订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.<span class="title function_">update</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line">    <span class="comment">// 临时属性 - 触发 getter</span></span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="variable language_">this</span>;</span><br><span class="line">    key.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">key</span></span><br><span class="line">      .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue3-数据绑定"><a href="#vue3-数据绑定" class="headerlink" title="vue3 数据绑定"></a>vue3 数据绑定</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿婆主：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>更多：&#123;&#123;more.like&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;more.like&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue3数据绑定.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> &#123; createApp &#125; = <span class="title class_">Vue</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>: <span class="string">&quot;蛋老师&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">more</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">like</span>: <span class="string">&quot;一键三连&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>绑定代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO：</span></span><br><span class="line"><span class="comment"> * 1. 对嵌套对象，依赖会有重复；</span></span><br><span class="line"><span class="comment"> * 2. 目前，对一个状态修改，会造成所有订阅者做update操作</span></span><br><span class="line"><span class="comment"> * 3. 需要用 Vue.createApp 的形式绑定this，之后调用mount，与Vue3原版不同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = &#123;</span><br><span class="line">  <span class="attr">$el</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">$data</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">createApp</span>: <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = <span class="title function_">reactive</span>(obj.<span class="title function_">data</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mount</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="title class_">Compile</span>(el, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板解析，替换DOM</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Compile</span>(<span class="params">element, vm</span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(element);</span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> ((child = vm.<span class="property">$el</span>.<span class="property">firstChild</span>)) &#123;</span><br><span class="line">    fragment.<span class="title function_">append</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fragment_compile</span>(fragment);</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fragment_compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// 正则匹配模板语法，如 &#123;&#123; name &#125;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/\&#123;\&#123;\s*(\S+)\s*\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> xxx = node.<span class="property">nodeValue</span>;</span><br><span class="line">      <span class="keyword">let</span> result = pattern.<span class="title function_">exec</span>(node.<span class="property">nodeValue</span>);</span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = result[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> value = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">        node.<span class="property">nodeValue</span> = xxx.<span class="title function_">replace</span>(pattern, value);</span><br><span class="line">        <span class="comment">// 创建订阅者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, result[<span class="number">1</span>], <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;替换DOM &quot;</span>, newValue);</span><br><span class="line">          node.<span class="property">nodeValue</span> = xxx.<span class="title function_">replace</span>(pattern, newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; node.<span class="property">nodeName</span> === <span class="string">&quot;INPUT&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> attr = <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">attributes</span>);</span><br><span class="line">      attr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.<span class="property">nodeName</span> === <span class="string">&quot;v-model&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = i.<span class="property">nodeValue</span></span><br><span class="line">            .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">          node.<span class="property">value</span> = value;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, i.<span class="property">nodeValue</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">            node.<span class="property">value</span> = newValue;</span><br><span class="line">          &#125;);</span><br><span class="line">          node.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;,&#x27;like&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr1 = i.<span class="property">nodeValue</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr2 = arr1.<span class="title function_">slice</span>(<span class="number">0</span>, arr1.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// vm.$data.more</span></span><br><span class="line">            <span class="keyword">const</span> final = arr2.<span class="title function_">reduce</span>(</span><br><span class="line">              <span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current],</span><br><span class="line">              vm.<span class="property">$data</span></span><br><span class="line">            );</span><br><span class="line">            final[arr1[arr1.<span class="property">length</span> - <span class="number">1</span>]] = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fragment_compile</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DOM 回填</span></span><br><span class="line">  vm.<span class="property">$el</span>.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖，收集并通知订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收集订阅者</span></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知订阅者</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.<span class="title function_">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅者</span></span><br><span class="line"><span class="comment"> * 做什么：视图变化时，修改数据模型</span></span><br><span class="line"><span class="comment"> * 什么时候创建：模板解析时，就创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line">    <span class="comment">// 临时属性</span></span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 触发getter，会执行 Proxy.get</span></span><br><span class="line">    key.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">key</span></span><br><span class="line">      .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 创建依赖</span></span><br><span class="line"><span class="keyword">const</span> dependency = <span class="keyword">new</span> <span class="title class_">Dependency</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">data_obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data_obj !== <span class="string">&quot;object&quot;</span> &amp;&amp; data_obj != <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 代理 数据对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(data_obj, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 订阅者加入依赖实例的数组中</span></span><br><span class="line">      <span class="title class_">Dependency</span>.<span class="property">temp</span> &amp;&amp; dependency.<span class="title function_">addSub</span>(<span class="title class_">Dependency</span>.<span class="property">temp</span>);</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">      <span class="comment">// console.log(`获取 $&#123;propKey&#125;---$&#123;value&#125;`)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> ? <span class="title function_">reactive</span>(value) : value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(`设置 $&#123;propKey&#125;---$&#123;JSON.stringify(value)&#125;`);</span></span><br><span class="line">      <span class="comment">// // todo: 并没有指定 propKey，会触发所有订阅者</span></span><br><span class="line">      <span class="keyword">const</span> rs = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">      dependency.<span class="title function_">notify</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">dir</span>(dependency);</span><br><span class="line">      <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue2-生命周期"><a href="#vue2-生命周期" class="headerlink" title="vue2 生命周期"></a>vue2 生命周期</h3><p>生命周期可以分为 8 个阶段，创建前后、挂载前后，更新前后，卸载前后，以及其他开启和关闭 Keepalive，捕获后代组件的错误，下面是 8 个阶段：</p>
<ul>
<li>beforeCreate</li>
<li>created: 数据监听完成，可获取 data 和 methods</li>
<li>beforeMount</li>
<li>mounted ：DOM 渲染完成，可以获取 DOM</li>
<li>beforeUpdate：数据更新完成，View 层还未更新</li>
<li>updated：视图层数据已经是最新的</li>
<li>beforeDestroy：组件的数据和方法都仍有效</li>
<li>destroyed：组件销毁</li>
</ul>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>父子组价的生命周期的关系：父组件 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子组件 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p>子组件更新阶段：父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<h3 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h3><p>computed 有缓存机制，当依赖没有变化时，重新调用 computed，不会重新运行，结果会直接从缓存中获取。<br>watch 主要用来监听特定属性的变化，从而执行回调，进行特定操作。<br>所以当两者都可以使用的时候，建议使用 computed</p>
<h3 id="组件间通信方式"><a href="#组件间通信方式" class="headerlink" title="组件间通信方式"></a>组件间通信方式</h3><ul>
<li>父子关系的组件数据传递选择 props 与 $emit 进行传递，也可选择 ref</li>
<li>兄弟关系的组件数据传递可选择<code>$bus</code>，其次可以选择$parent 进行传递</li>
<li>祖先与后代组件数据传递可选择 attrs 与 listeners 或者 Provide 与 Inject</li>
<li>复杂关系的组件数据传递可以通过 vuex 存放共享的变量</li>
</ul>
<p>父子：props $emit expose&#x2F;ref attrs v-model<br>兄弟：mitt eventbBus<br>跨级：provide、inject<br>插件：vuex pinia</p>
<h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p><strong>props</strong>，父 -&gt; 子，父组件向子组件传入数据。<br>使用案例，点击按钮，修改子组件中的内容：<br>父组件 App 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">CompA</span> <span class="keyword">from</span> <span class="string">&quot;./CompA.vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 组件选项</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">CompA</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 此处声明一些响应式状态</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">contentA</span>: <span class="string">&quot;默认数据&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">changeAcontent</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> (<span class="variable language_">this</span>.<span class="property">contentA</span> = <span class="string">&quot;这是父组件传给CompA的数据&quot;</span>), <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAcontent&quot;</span>&gt;</span>修改A的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>-----------------------------------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CompA</span> <span class="attr">:content</span>=<span class="string">&quot;contentA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">CompA</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件 CompA 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;component&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">title</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>: <span class="string">&quot;这里是子组件CompA&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">content</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>: <span class="string">&quot;CompA的内容&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-class">.component</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#e09f00</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#ffce46</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#999</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%AD%90%E9%80%9A%E4%BF%A1.png"></p>
<h3 id="nextTick-机制"><a href="#nextTick-机制" class="headerlink" title="nextTick 机制"></a>nextTick 机制</h3><p>在下一轮 DOM 更新循环之后执行延迟回调函数，数据更新后立即使用 nextTick，此时 DOM 是更新之后的。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>nextTick 接收两个参数，一个是回调函数，另一个是上下文。回调函数会被放在 callbacks 中，也就是异步操作队列。新增回调函数后又执行了 timerFunc 函数，执行异步。timeFunc 的实现由当前运行环境决定，分别由<code>Promise.then</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code>。总结：</p>
<ol>
<li>把回调函数放入 callbacks 等待执行</li>
<li>将执行函数放到微任务或者宏任务中</li>
<li>事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调</li>
</ol>
<h3 id="data-为什么是个函数"><a href="#data-为什么是个函数" class="headerlink" title="data 为什么是个函数"></a>data 为什么是个函数</h3><p>一个组件是有多个实例的，这些实例本质上用的都是同一个构造函数，如果 data 是对象的话，修改一个实例中的 data 会影响到其他实例的数据，为确保不冲突，data 必须是个函数。</p>
<h3 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a>v-if 和 v-for</h3><p>vue2 中，v-for 的优先级大于 v-if，每次渲染都会先循环再判断，带来性能的浪费。<br>而 vue3 中，v-if 的优先级大于 v-for，if 无法访问到 for 定义域中定义的变量别名，会抛出错误。<br>总结，v-if 和 v-for 的优先级本身就不明显，加上会造成性能浪费，所以需要将 v-if 和 for 拆开，不能放在同一个节点上。</p>
<h3 id="keep-alive-的实现"><a href="#keep-alive-的实现" class="headerlink" title="keep-alive 的实现"></a>keep-alive 的实现</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染<br>场景：tabs 标签页 后台导航，vue 性能优化<br>原理：Vue.js 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点的而不是直接存储 DOM 结构。它将满足条件（pruneCache 与 pruneCache）的组件在 cache 对象中缓存起来，在需要重新渲染的时候再将 vnode 节点从 cache 对象中取出并渲染。</p>
<h3 id="插槽-slot"><a href="#插槽-slot" class="headerlink" title="插槽 slot"></a>插槽 slot</h3><p>网页结构占位符，分为<code>默认插槽</code>、<code>具名插槽</code>、<code>作用域插槽</code>：</p>
<ul>
<li>默认插槽</li>
<li>具名插槽，<code>slot</code>上加上<code>name</code>属性，标注插槽名。父组件使用时通过<code>&lt;template v-slot:default&gt;默认插槽&lt;/template&gt;</code>的方式，将具体内容加到子组件的指定位置上。<code>v-slot:</code>可简写成<code>#</code></li>
<li>作用域插槽</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子组件 Child.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">testProps</span>=<span class="string">&quot;子组件的值&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--父组件 Parent.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="https-的基本概念"><a href="#https-的基本概念" class="headerlink" title="https 的基本概念"></a>https 的基本概念</h3><p>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。</p>
<p>https 协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p>
<h3 id="http-和-https-的区别？"><a href="#http-和-https-的区别？" class="headerlink" title="http 和 https 的区别？"></a>http 和 https 的区别？</h3><ul>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>Https 协议需要 ca 证书，费用较高。</li>
<li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li>
<li>http 的连接很简单，是无状态的。</li>
</ul>
<blockquote>
<p>记忆口诀：明文传输超文本，安全等级各不同。CA 证书费用高，无状连接端难同。</p>
</blockquote>
<h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42bc6f45451457fa6d614fb27534516~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>
<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li>
<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>
<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>
</ol>
<blockquote>
<p>记忆口诀：一连二传三协商，四建五得六使用。</p>
</blockquote>
<h4 id="https-协议的优缺点"><a href="#https-协议的优缺点" class="headerlink" title="https 协议的优缺点"></a>https 协议的优缺点</h4><ul>
<li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li>
<li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
<li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li>
<li>SSL 证书也需要钱，功能越强大的<code>证书费用</code>越高。</li>
<li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li>
</ul>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li>
<li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</span><br></pre></td></tr></table></figure>

<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol>
<li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li>
</ol>
<p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
<p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol>
<li><p>TCP 是面向<code>连接</code>的，而 UDP 是面向无连接的。</p>
</li>
<li><p>TCP 仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>TCP 的三次握手保证了连接的<code>可靠性</code>; UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p>
</li>
<li><p>UDP 的<code>头部开销</code>比 TCP 的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p>
</li>
</ol>
<h3 id="DNS-服务"><a href="#DNS-服务" class="headerlink" title="DNS 服务"></a>DNS 服务</h3><p>DNS：域名系统，将域名与对应的 IP 进行转换的服务系统；</p>
<p>解析域名的过程如下：</p>
<ol>
<li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p>
</li>
<li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p>
</li>
<li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p>
</li>
<li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p>
<ol>
<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>
<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
<li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li>
</ol>
</li>
<li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p>
</li>
<li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p>
</li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="类组件和函数组件的区别"><a href="#类组件和函数组件的区别" class="headerlink" title="类组件和函数组件的区别"></a>类组件和函数组件的区别</h3><p><strong>编写方式</strong><br>类组件需要继承<code>Component</code>对象，并需要用<code>render</code>函数包装返回的JSX对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态管理</strong><br>类组件中，使用<code>this.state</code>设置初始状态，通过<code>this.setState()</code>重新覆盖状态；<br>函数组件中，通过React的<code>useState</code>，获取状态和对应setter。如通过<code>const [count, setCount] = React.useState(0);</code>可设置count状态。</p>
<p><strong>生命周期</strong><br>函数组件通过 useEffect Hook 对应着类组件的 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数。<br><code>useEffect(fn[,list])</code>接收两个参数，fn回调函数，list是个数组，参数的不同情况对应不同的周期函数：</p>
<ul>
<li>为空时，相当于<code>componentDidMount</code>，<code>componentDidUpdate</code>，每次渲染都会触发；</li>
<li>为空数组<code>[]</code>时，用于模拟 <code>componentDidMount</code> 挂载完成</li>
<li>不为空时，数组中的任意一个状态发生变化，都会触发程序，相当于<code>componentDidUpdate</code></li>
<li>当<code>fn</code>中返回一个函数A时，当组件卸载时，会触发，用于模拟 <code>componentWillUnmount</code></li>
</ul>
<p><strong>调用方式</strong><br>React内部使用类组件时，首先需要创建一个组件实例，再调用render获取组件内容。而函数组件直接执行函数即可。</p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p><strong>父子</strong>：父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数；<br><strong>子父</strong>：父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值；<br><strong>兄弟</strong>：通过父组件，传递数据；<br><strong>跨级</strong>：使用<code>React.createContext</code>创建一个<code>context</code>，再通过<code>Provider</code>组件用于创建数据源，<code>Consumer</code>组件用于接收数据；<br><strong>非关系组件</strong>：</p>
<ul>
<li>如果项目复杂的话，采用<code>redux</code>进行全局的数据流管理</li>
<li>采用发布订阅的<code>Event Bus</code>来进行组件通信</li>
</ul>
<p>这里举一个实现Event Bus的例子（<a target="_blank" rel="noopener" href="https://blog.csdn.net/wengqt/article/details/80114590">原文链接</a>）：A和B是两个互不相关的组件，A组件的功能是登录，B组件的功能是登录之后显示用户名，这里就需要A组件将用户名传递给B组件。那么我们应该怎么做呢？</p>
<p>在A组件中注册&#x2F;发布一个type为login的事件；<br>在B组件中注册一个监听&#x2F;订阅，监听login事件的触发；<br>然后当登录的时候login事件触发，然后B组件就可以触发这个事件的回调函数。<br>Event Bus 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="variable language_">this</span>.<span class="property">events</span> || <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先构造函数需要存储event事件，使用键值对存储</span></span><br><span class="line"><span class="comment">//然后我们需要发布事件，参数是事件的type和需要传递的参数</span></span><br><span class="line"><span class="title class_">EventBus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params">type, ...args</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> e; </span><br><span class="line">    e = <span class="variable language_">this</span>.<span class="property">events</span>[type];  </span><br><span class="line">    <span class="comment">// 查看这个type的event有多少个回调函数，如果有多个需要依次调用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; e.<span class="property">length</span>; i++) &#123;   </span><br><span class="line">            e[i].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);    </span><br><span class="line">          &#125;  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          e[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  </span><br><span class="line">         &#125;  </span><br><span class="line">   &#125;;</span><br><span class="line"> <span class="comment">//然后我们需要写监听函数，参数是事件type和触发时需要执行的回调函数</span></span><br><span class="line"> <span class="title class_">EventBus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addListener</span> = <span class="keyword">function</span>(<span class="params">type, fun</span>) &#123; </span><br><span class="line">       <span class="keyword">const</span> e = <span class="variable language_">this</span>.<span class="property">events</span>[type]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!e) &#123;   <span class="comment">//如果从未注册过监听函数，则将函数放入数组存入对应的键名下</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">events</span>[type]= [fun];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果注册过，则直接放入</span></span><br><span class="line">           e.<span class="title function_">push</span>(fun);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure>
<p>A组件中注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">emit</span>(<span class="string">&#x27;login&#x27;</span>,values.<span class="property">userName</span>)</span><br></pre></td></tr></table></figure>
<p>B组件中监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">addListener</span>(<span class="string">&#x27;login&#x27;</span>,<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">user</span>:name&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="setState机制"><a href="#setState机制" class="headerlink" title="setState机制"></a>setState机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(partialState[, callback])</span><br></pre></td></tr></table></figure>
<p><code>partialState</code>接收对象或函数或null;<br>callback：参数可选，更新后的回调函数;</p>
<p>setState更新数据的情况可分为：</p>
<ul>
<li>异步更新：参数传入对象时属于异步，无法在更新后，紧接着获取最新数据。可以在callback中读取最新数据；</li>
<li>同步更新：将setState的调用包裹在setTimeout或原生dom事件中；</li>
<li>批量更新：当处于异步更新时，对同一个值进行多次 setState，后面的更新会覆盖前面的更新，最后只执行最后一次更新操作。可以通过传入函数完成批量更新。函数参数<code>(prevState, props)</code>，通过prevState访问当前值，并且return最新数据。实例代码如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/22/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/" data-id="clfr003qw0001ncaaf666cu5d" data-title="前端八股文" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何使用MDN文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MDN%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2023-03-22T13:42:24.866Z" itemprop="datePublished">2023-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MDN%E6%96%87%E6%A1%A3/">利用好文档、好资源</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如何更好的使用文档，在查阅文档的过程中，按照参考文献一路往下看，基本最后都会指向MDN网站的一个冷门文档。这篇文章就是为了记录那些有用的文档。</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>介绍</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>Web 相关术语的定义</td>
<td>web专业术语的定义，对面试、写博客都用帮助</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary">https://developer.mozilla.org/zh-CN/docs/Glossary</a></td>
</tr>
<tr>
<td>JavaScript 使用指南</td>
<td>介绍如何使用 JavaScript，并且给出了语言概述</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide</a></td>
</tr>
</tbody></table>
<h1 id="Web-相关术语的定义"><a href="#Web-相关术语的定义" class="headerlink" title="Web 相关术语的定义"></a>Web 相关术语的定义</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary">https://developer.mozilla.org/zh-CN/docs/Glossary</a></p>
<h1 id="JavaScript-使用指南"><a href="#JavaScript-使用指南" class="headerlink" title="JavaScript 使用指南"></a>JavaScript 使用指南</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide</a></p>
<h1 id="ES入门-阮一峰"><a href="#ES入门-阮一峰" class="headerlink" title="ES入门-阮一峰"></a>ES入门-阮一峰</h1><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MDN%E6%96%87%E6%A1%A3/" data-id="clfmqs4tk001jtwaaf26z48yj" data-title="利用好文档、好资源" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-060CSS面试总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/28/060CSS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-04-28T13:42:12.000Z" itemprop="datePublished">2023-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/28/060CSS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">060CSS面试总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h4><ul>
<li>采用语义化标签，能提高代码可读性和可维护性；</li>
<li>让搜索引擎更容易读懂，完成SEO优化</li>
</ul>
<h4 id="块状元素-amp-内联元素"><a href="#块状元素-amp-内联元素" class="headerlink" title="块状元素&amp;内联元素"></a>块状元素&amp;内联元素</h4><ul>
<li>块状元素指display&#x3D;block或table的元素，元素独占一行，如div,h,ul,ol,table,p等</li>
<li>内联元素指display&#x3D;inline或inline-block,元素会紧接着排列，直至网页边界换行，如span，img,a,input,button</li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><p>CSS盒子由content、border、padding、margin组成。</p>
<ul>
<li>标准盒子模型，width属性只是内容宽度，不包含内边距和边框。模型总宽&#x3D;width+padding+border+margin；</li>
<li>IE 怪异盒子模型，width属性&#x3D;内容宽度+padding+border。模型总宽&#x3D;width+margin;</li>
</ul>
<p>CSS中通过box-sizing设置盒子的模型，值各含义：</p>
<ul>
<li>content-box，标准盒子，默认值</li>
<li>border-box，IE怪异盒子</li>
<li>inherit，从父元素继承</li>
</ul>
<h4 id="margin纵向重叠"><a href="#margin纵向重叠" class="headerlink" title="margin纵向重叠"></a>margin纵向重叠</h4><p>两点：<br>相邻元素的margin-top，bottom会发生重叠；<br>空白内容的元素也会重叠；<br>解决方案：</p>
<ul>
<li>设置外层的padding代替margin</li>
<li>使元素不为空，如设置透明边框</li>
<li>触发BFC，如overflow:hidden、设置position</li>
</ul>
<h4 id="margin负值的各种情况"><a href="#margin负值的各种情况" class="headerlink" title="margin负值的各种情况"></a>margin负值的各种情况</h4><p>margin-top,left 负值，元素上移，左移<br>margin-right 负值，右侧元素左移，自身不受影响<br>margin-bottom 负值，下方元素上移，自身不受影响</p>
<h4 id="BFC的理解和应用"><a href="#BFC的理解和应用" class="headerlink" title="BFC的理解和应用"></a>BFC的理解和应用</h4><p>block format context 块级格式化上下文</p>
<ul>
<li><p>一块独立的渲染区域，内部元素的渲染不会影响边界之外的元素</p>
</li>
<li><p>形成条件：</p>
<ul>
<li>float不是none；</li>
<li>position是absolute或fixed；</li>
<li>overflow不是visible；</li>
<li>display是flex, inline-block等；</li>
</ul>
</li>
<li><p>常见应用</p>
<ul>
<li>清除浮动</li>
</ul>
</li>
</ul>
<h4 id="float应用-圣杯布局和双飞翼布局"><a href="#float应用-圣杯布局和双飞翼布局" class="headerlink" title="float应用-圣杯布局和双飞翼布局"></a>float应用-圣杯布局和双飞翼布局</h4><p>圣杯布局、双飞翼布局是PC端的布局方案</p>
<p>技术总结：</p>
<ul>
<li>使用float布局</li>
<li>两侧使用margin负值，以便和中间内容横向重叠</li>
<li>通过padding或margin为两侧留白</li>
</ul>
<p>圣杯布局实现细节：通过padding留白，左侧再设置 position：relative、right 移动位置；<br>双飞翼布局实现细节：中间栏需要再嵌套一层 div</p>
<h4 id="手写clearfix"><a href="#手写clearfix" class="headerlink" title="手写clearfix"></a>手写clearfix</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/28/060CSS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" data-id="clhg6z38i0003wsaa467odsyw" data-title="060CSS面试总结" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-058-59学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/27/058-59%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2023-04-27T03:14:56.000Z" itemprop="datePublished">2023-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/27/058-59%E5%AD%A6%E4%B9%A0/">058学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="盒模型计算"><a href="#盒模型计算" class="headerlink" title="盒模型计算"></a>盒模型计算</h4><p>offsetWidth&#x3D;内容宽度+padding+border</p>
<h4 id="margin纵向重叠（边距塌陷）"><a href="#margin纵向重叠（边距塌陷）" class="headerlink" title="margin纵向重叠（边距塌陷）"></a>margin纵向重叠（边距塌陷）</h4><p>空元素margin值会忽略，两值取大者</p>
<h4 id="margin负值问题"><a href="#margin负值问题" class="headerlink" title="margin负值问题"></a>margin负值问题</h4><p>margin-top,left 负值，元素上移，左移<br>margin-right 负值，右侧元素左移，自身不受影响<br>margin-bottom 负值，下方元素上移，自身不受影响</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/27/058-59%E5%AD%A6%E4%B9%A0/" data-id="clhg6z38f0001wsaags28dwwp" data-title="058学习" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-057React学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/25/057React%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2023-04-25T02:15:03.000Z" itemprop="datePublished">2023-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/25/057React%E5%AD%A6%E4%B9%A0/">057React学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>todo: 明天写吧！！！</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>创建阶段：</p>
<ol>
<li>constructor<br>方法内部通过super获取父组件的props，通常在这里初始化state、挂载方法</li>
<li>getDerivedStateFromProps(newProps,prevState)<br><strong>接收参数</strong>：newProps，即将更新的props；prevState，上一个状态的state<br><strong>返回值</strong>：newState 新的state对象 | null，表示不需要更新<br>组件创建和更新阶段，不论是props变化还是state变化，也会调用。可以比较props、state，防止无用state更新</li>
<li>render</li>
</ol>
<p>返回JSX对象，用于渲染DOM结构<br>4. componentDidMount</p>
<p>组件挂载到真实DOM后执行。多用于执行数据获取，事件监听等操作。</p>
<p>更新阶段：</p>
<ol>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
</ol>
<p>基于当前props和state确定组件是否需要更新<br>3. render<br>4. getSnapshotBeforeUpdate(prevProps, prevState)<br>返回的一个<code>Snapshot</code>值，作为componentDidUpdate第三个参数传入<br>执行之时DOM元素还没有被更新，目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的<br>5. componentDidUpdate<br>组件更新后触发，可以根据前后的props和state的变化做相应的操作，如获取数据，修改DOM样式等</p>
<p>销毁阶段：<br>componentUnmounted<br>组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等</p>
<h3 id="Fiber-x2F-ˈfaɪbər-x2F-这块不理解"><a href="#Fiber-x2F-ˈfaɪbər-x2F-这块不理解" class="headerlink" title="Fiber &#x2F;ˈfaɪbər&#x2F; 这块不理解"></a>Fiber &#x2F;ˈfaɪbər&#x2F; 这块不理解</h3><p><strong>背景（解决什么问题）</strong><br>JS引擎和页面渲染引擎的两个线程是互斥的。如果JS线程长时间占用主线程，那么页面渲染就不能不等待，页面长期不更新，会导致页面响应性变差，用户可能会感觉卡顿。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/25/057React%E5%AD%A6%E4%B9%A0/" data-id="clhg6z38b0000wsaa1dt0ejys" data-title="057React学习" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-056React中setState机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/24/056React%E4%B8%ADsetState%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2023-04-24T09:22:27.000Z" itemprop="datePublished">2023-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/24/056React%E4%B8%ADsetState%E6%9C%BA%E5%88%B6/">056React中setState机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="setState机制"><a href="#setState机制" class="headerlink" title="setState机制"></a>setState机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(partialState[, callback])</span><br></pre></td></tr></table></figure>
<p><code>partialState</code>接收对象或函数或null;<br>callback：参数可选，更新后的回调函数;</p>
<p>setState更新数据的情况可分为：</p>
<ul>
<li>异步更新：参数传入对象时属于异步，无法在更新后，紧接着获取最新数据。可以在callback中读取最新数据；</li>
<li>同步更新：将setState的调用包裹在setTimeout或原生dom事件中；</li>
<li>批量更新：当处于异步更新时，对同一个值进行多次 setState，后面的更新会覆盖前面的更新，最后只执行最后一次更新操作。可以通过传入函数完成批量更新。函数参数<code>(prevState, props)</code>，通过prevState访问当前值，并且return最新数据。实例代码如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/24/056React%E4%B8%ADsetState%E6%9C%BA%E5%88%B6/" data-id="clguxnq8h0002d4aa9ub4h5os" data-title="056React中setState机制" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-055React组件通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/23/055React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2023-04-23T08:42:04.000Z" itemprop="datePublished">2023-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/23/055React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">055React组件通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对自己感兴趣的领域，要多学习</p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p><strong>父子</strong>：父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数；<br><strong>子父</strong>：父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值；<br><strong>兄弟</strong>：通过父组件，传递数据；<br><strong>跨级</strong>：使用<code>React.createContext</code>创建一个<code>context</code>，再通过<code>Provider</code>组件用于创建数据源，<code>Consumer</code>组件用于接收数据；<br><strong>非关系组件</strong>：</p>
<ul>
<li>如果项目复杂的话，采用<code>redux</code>进行全局的数据流管理</li>
<li>采用发布订阅的<code>Event Bus</code>来进行组件通信</li>
</ul>
<p>这里举一个实现Event Bus的例子（<a target="_blank" rel="noopener" href="https://blog.csdn.net/wengqt/article/details/80114590">原文链接</a>）：A和B是两个互不相关的组件，A组件的功能是登录，B组件的功能是登录之后显示用户名，这里就需要A组件将用户名传递给B组件。那么我们应该怎么做呢？</p>
<p>在A组件中注册&#x2F;发布一个type为login的事件；<br>在B组件中注册一个监听&#x2F;订阅，监听login事件的触发；<br>然后当登录的时候login事件触发，然后B组件就可以触发这个事件的回调函数。<br>Event Bus 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="variable language_">this</span>.<span class="property">events</span> || <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先构造函数需要存储event事件，使用键值对存储</span></span><br><span class="line"><span class="comment">//然后我们需要发布事件，参数是事件的type和需要传递的参数</span></span><br><span class="line"><span class="title class_">EventBus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params">type, ...args</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> e; </span><br><span class="line">    e = <span class="variable language_">this</span>.<span class="property">events</span>[type];  </span><br><span class="line">    <span class="comment">// 查看这个type的event有多少个回调函数，如果有多个需要依次调用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; e.<span class="property">length</span>; i++) &#123;   </span><br><span class="line">            e[i].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);    </span><br><span class="line">          &#125;  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          e[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  </span><br><span class="line">         &#125;  </span><br><span class="line">   &#125;;</span><br><span class="line"> <span class="comment">//然后我们需要写监听函数，参数是事件type和触发时需要执行的回调函数</span></span><br><span class="line"> <span class="title class_">EventBus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addListener</span> = <span class="keyword">function</span>(<span class="params">type, fun</span>) &#123; </span><br><span class="line">       <span class="keyword">const</span> e = <span class="variable language_">this</span>.<span class="property">events</span>[type]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!e) &#123;   <span class="comment">//如果从未注册过监听函数，则将函数放入数组存入对应的键名下</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">events</span>[type]= [fun];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果注册过，则直接放入</span></span><br><span class="line">           e.<span class="title function_">push</span>(fun);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure>
<p>A组件中注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">emit</span>(<span class="string">&#x27;login&#x27;</span>,values.<span class="property">userName</span>)</span><br></pre></td></tr></table></figure>
<p>B组件中监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">addListener</span>(<span class="string">&#x27;login&#x27;</span>,<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">user</span>:name&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/23/055React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" data-id="clguxnq8g0000d4aaa0ythw9i" data-title="055React组件通信" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-053-54React题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/22/053-54React%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-04-22T09:05:17.000Z" itemprop="datePublished">2023-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/22/053-54React%E9%A2%98/">053-54React题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天没写。写到类组件和函数组件的对比。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>一种”编程范式”（programming paradigm），一种编写程序的方法论。它倡导利用简单的执行单元使计算结果不断渐进，最终完成复杂的任务。函数式编程旨在尽可能的提高代码的无状态性和不变性。简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。<br>编程范式主要有三种：命令式编程、声明式编程，以及函数式编程。</p>
<ul>
<li><p>与命令式的区别：它关注执行结果，命令式更强调执行过程。</p>
</li>
<li><p>与声明式的区别：它并不需要进一步抽象封装成类（声明式编程，我理解就是多了类）。</p>
</li>
<li><p>优点：</p>
<ul>
<li>更简单的复用，不用考虑内部变化和外部影响</li>
<li>更好的管理状态，提倡无状态，或者说更少的状态，能更大程度的减少未知情况，减少意外错误。</li>
<li>代码可组合</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能开销，对方法的过度包装，从而产生上下文切换的性能开销。</li>
<li>资源占用，为了实现对象状态的不可变，往往会创建新的对象。</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作，会造成性能开销。为了优化，我们往往需要写成<strong>尾递归</strong>形式。</li>
</ul>
</li>
</ul>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>给定的输入参数，会返回相同的结果，并且所有的数据是不可变的。纯函数&#x3D;无状态+数据不可变。</p>
<h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><p>执行了与返回值无关的事件，如修改了全局变量，修改了传入的参数，发送请求（useEffect）等等。即数据不可变。</p>
<h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p>日常前端开发三种都会使用，以命令式为主，当需要提高代码的复用性，减少重复的时候，会将一些代码抽离成函数。声明式编程会少一些，因为前端对类的使用会少一些。近些前端框架都开始强调函数式编程，大势所趋。</p>
<h3 id="类组件和函数组件的区别"><a href="#类组件和函数组件的区别" class="headerlink" title="类组件和函数组件的区别"></a>类组件和函数组件的区别</h3><p><strong>编写方式</strong><br>类组件需要继承<code>Component</code>对象，并需要用<code>render</code>函数包装返回的JSX对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态管理</strong><br>类组件中，使用<code>this.state</code>设置初始状态，通过<code>this.setState()</code>重新覆盖状态；<br>函数组件中，通过React的<code>useState</code>，获取状态和对应setter。如通过<code>const [count, setCount] = React.useState(0);</code>可设置count状态。</p>
<p><strong>生命周期</strong><br>函数组件通过 useEffect Hook 对应着类组件的 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数。<br><code>useEffect(fn[,list])</code>接收两个参数，fn回调函数，list是个数组，参数的不同情况对应不同的周期函数：</p>
<ul>
<li>为空时，相当于<code>componentDidMount</code>，<code>componentDidUpdate</code>，每次渲染都会触发；</li>
<li>为空数组<code>[]</code>时，用于模拟 <code>componentDidMount</code> 挂载完成</li>
<li>不为空时，数组中的任意一个状态发生变化，都会触发程序，相当于<code>componentDidUpdate</code></li>
<li>当<code>fn</code>中返回一个函数A时，当组件卸载时，会触发，用于模拟 <code>componentWillUnmount</code></li>
</ul>
<p><strong>调用方式</strong><br>React内部使用类组件时，首先需要创建一个组件实例，再调用render获取组件内容。而函数组件直接执行函数即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/22/053-54React%E9%A2%98/" data-id="clgs48fqd0000dkaa34z1fy5n" data-title="053-54React题" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-052React实战7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/20/052React%E5%AE%9E%E6%88%987/" class="article-date">
  <time class="dt-published" datetime="2023-04-20T14:16:05.000Z" itemprop="datePublished">2023-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a>►<a class="article-category-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/%E4%BB%BF%E6%90%BA%E7%A8%8B%E7%BD%91%E7%AB%99/">仿携程网站</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/20/052React%E5%AE%9E%E6%88%987/">052React实战7</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React项目"><a href="#React项目" class="headerlink" title="React项目"></a>React项目</h1><p>旅游电商项目教学部分已经完成了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/20/052React%E5%AE%9E%E6%88%987/" data-id="clgp7imc30003zwaaadiiazug" data-title="052React实战7" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/%E4%BB%BF%E6%90%BA%E7%A8%8B%E7%BD%91%E7%AB%99/">仿携程网站</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-defineProperty/" rel="tag">Object.defineProperty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bind/" rel="tag">bind</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computed/" rel="tag">computed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data/" rel="tag">data()</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eventloop/" rel="tag">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keep-alive/" rel="tag">keep-alive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/new/" rel="tag">new</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/" rel="tag">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot/" rel="tag">slot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this%E5%AF%B9%E8%B1%A1/" rel="tag">this对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/watch/" rel="tag">watch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" rel="tag">数据绑定</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag">生命周期</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" rel="tag">节流防抖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 12.5px;">CSS</a> <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JS/" style="font-size: 12.5px;">JS</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Object-defineProperty/" style="font-size: 10px;">Object.defineProperty</a> <a href="/tags/React/" style="font-size: 20px;">React</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Vue/" style="font-size: 17.5px;">Vue</a> <a href="/tags/bind/" style="font-size: 10px;">bind</a> <a href="/tags/computed/" style="font-size: 10px;">computed</a> <a href="/tags/data/" style="font-size: 10px;">data()</a> <a href="/tags/eventloop/" style="font-size: 10px;">eventloop</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/keep-alive/" style="font-size: 10px;">keep-alive</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/nextTick/" style="font-size: 10px;">nextTick</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/slot/" style="font-size: 10px;">slot</a> <a href="/tags/this%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">this对象</a> <a href="/tags/uniapp/" style="font-size: 15px;">uniapp</a> <a href="/tags/watch/" style="font-size: 10px;">watch</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 10px;">作用域</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">数据类型</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" style="font-size: 10px;">数据绑定</a> <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="font-size: 10px;">生命周期</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">网络</a> <a href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" style="font-size: 10px;">节流防抖</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size: 10px;">闭包</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 17.5px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/28/060CSS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">060CSS面试总结</a>
          </li>
        
          <li>
            <a href="/2023/04/27/058-59%E5%AD%A6%E4%B9%A0/">058学习</a>
          </li>
        
          <li>
            <a href="/2023/04/25/057React%E5%AD%A6%E4%B9%A0/">057React学习</a>
          </li>
        
          <li>
            <a href="/2023/04/24/056React%E4%B8%ADsetState%E6%9C%BA%E5%88%B6/">056React中setState机制</a>
          </li>
        
          <li>
            <a href="/2023/04/23/055React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">055React组件通信</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>