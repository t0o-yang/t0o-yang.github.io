<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>python实现KNN算法 | ylog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="实现knn算法knn算法介绍knn（k-NearestNeighbor），中译：k最近邻分类算法。算法要完成的事情是：一组已分类数据集，一组待分数据，根据knn算法将待分数据分好类。明白要做什么，这个过程的分类准则就是knn算法。其核心就是，由近邻数据的类别决定待分数据的类别。那么判断是否为近邻又由什么决定呢？——距离，确切来说是，欧式距离。空间中有两个点 a(x0, y0)，b(x1, y1)">
<meta property="og:type" content="article">
<meta property="og:title" content="python实现KNN算法">
<meta property="og:url" content="http://example.com/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ylog">
<meta property="og:description" content="实现knn算法knn算法介绍knn（k-NearestNeighbor），中译：k最近邻分类算法。算法要完成的事情是：一组已分类数据集，一组待分数据，根据knn算法将待分数据分好类。明白要做什么，这个过程的分类准则就是knn算法。其核心就是，由近邻数据的类别决定待分数据的类别。那么判断是否为近邻又由什么决定呢？——距离，确切来说是，欧式距离。空间中有两个点 a(x0, y0)，b(x1, y1)">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="http://example.com/images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B2.png">
<meta property="og:image" content="http://example.com/images/knn%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="article:published_time" content="2023-04-06T07:58:00.591Z">
<meta property="article:modified_time" content="2023-04-06T08:30:39.202Z">
<meta property="article:author" content="yh0ng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.png">
  
    <link rel="alternate" href="/atom.xml" title="ylog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ylog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Feed RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Cerca"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Cerca"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Python语言实现KNN算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-04-06T07:58:00.591Z" itemprop="datePublished">2023-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      python实现KNN算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="实现knn算法"><a href="#实现knn算法" class="headerlink" title="实现knn算法"></a>实现knn算法</h1><h2 id="knn算法介绍"><a href="#knn算法介绍" class="headerlink" title="knn算法介绍"></a>knn算法介绍</h2><p><strong>knn（k-NearestNeighbor），中译：k最近邻分类算法</strong>。算法要完成的事情是：一组已分类数据集，一组待分数据，根据knn算法将待分数据分好类。<br>明白要做什么，这个过程的分类准则就是knn算法。其<strong>核心</strong>就是，<strong>由近邻数据的类别决定待分数据的类别。</strong><br>那么判断是否为近邻又由什么决定呢？——距离，确切来说是，<strong>欧式距离</strong>。空间中有两个点 a(x<del>0</del>, y<del>0</del>)，b(x<del>1</del>, y<del>1</del>) ，两点之间的距离就是欧式距离。公式请自查。<br>放图说话，下图都是表示knn决策过程。</p>
<p><img src="/../images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.png" alt="knn决策过程1"></p>
<p><img src="/../images/knn%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B2.png" alt="knn决策过程2"></p>
<p>其也能进行回归分析，详细内容请参考<strong>近邻算法_百度百科</strong>，点击<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=STA-SNpUskTFahm4e40lxLoFauAOQgU2ZejmD9LERZko7zXJpW5C3PEdGUlxTOckkYhWDP8yF9xD8FoAwGvoJBEZXn_rX5hLee-0oG3Fln-UYxQBDsGNuPlpr8C6MvB0ARBLxkG6gfxCQkhCbKXX5PoutWn5P9lx9B2YraqG68_&wd=&eqid=dbdd4a310075fec5000000035da0a9be">这里</a>。</p>
<h2 id="算法步骤及实现"><a href="#算法步骤及实现" class="headerlink" title="算法步骤及实现"></a>算法步骤及实现</h2><p><strong>具体实现参考了近邻算法_百度百科</strong>，下面将算法步骤和算法实现放在一起。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据存取方式采用<strong>操作列表</strong>的方式，这里考虑的是熟练度。当然<strong>推荐选择导入 Numpy ，操作效率更高</strong>。</p>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/../images/knn%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<h3 id="1-训练集和测试集"><a href="#1-训练集和测试集" class="headerlink" title="1.训练集和测试集"></a>1.训练集和测试集</h3><p>先获取训练集数据和测试集数据，实现过程中先采用的训练集和测试集是，自编的简单数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myDataset = &#123;<span class="string">&#x27;data&#x27;</span>:[[<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">             <span class="string">&#x27;target&#x27;</span>:[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;</span><br><span class="line">X_train, y_train = myDataset[<span class="string">&#x27;data&#x27;</span>], myDataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">X_test = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>具体真正使用的训练集和测试集是，鸢尾花数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris_dataset = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_dataset[<span class="string">&#x27;data&#x27;</span>], iris_dataset[<span class="string">&#x27;target&#x27;</span>], random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-设定k值"><a href="#2-设定k值" class="headerlink" title="2.设定k值"></a>2.设定k值</h3><p>k值，是决定了待测数据 X_test 会有 k 个邻居。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_neighbors</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;指定近邻个数&#x27;&#x27;&#x27;</span></span><br><span class="line">    self.n_neighbors = n_neighbors <span class="comment"># 近邻数</span></span><br><span class="line">    <span class="comment"># self.x_new = [] # 预测数据集</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建预先序列"><a href="#3-创建预先序列" class="headerlink" title="3.创建预先序列"></a>3.创建预先序列</h3><p>百科中第四步，<strong>优先级队列</strong>在本文名为：<strong>预先序列</strong> 。预先序列其实就是近邻序列，其大小等于 k ，具体说是，预先序列计算处理得到的距离的预先序列 <strong>distList</strong> 。关于创建预先序列的用途，我的理解是，<strong>当 k &gt; 1时，即待分数据会有 k 个邻居时，在不采用预先序列的情况下，同样的，会产生一个 k 大小的近邻序列，并且在生成序列过程中第 i ( i &lt; k ) 个数据都需要进行判断数据是否需要更新。而采用了预先序列，每次比大小的两方，一个是训练数据集，另一个就会变成 distList 中的最大值，更新最大值即可，会减少判断次数。</strong><br><code>使用每个数据的ID(索引)建立预先序列</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.idList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x_train)), self.n_neighbors) <span class="comment"># 获取空间大小为k的预先序列,k个随机的元组,k=n_neighbors</span></span><br></pre></td></tr></table></figure>

<p><code>计算距离</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_deftDist</span>(<span class="params">self, tp</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算测试数据与预先序列的距离&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">list</span> = [] <span class="comment"># 存放预测数据与预先序列的距离，列表含有k个距离</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    for i in range(len(self.x_new)):</span></span><br><span class="line"><span class="string">        tp = self.x_new[i]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        index = self.idList[j]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tp)):</span><br><span class="line">            <span class="built_in">sum</span> += (tp[k]-self.x_train[index][k])**<span class="number">2</span> </span><br><span class="line">        <span class="built_in">sum</span> = math.sqrt(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="built_in">list</span>.append(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h3 id="4-更新预先序列"><a href="#4-更新预先序列" class="headerlink" title="4.更新预先序列"></a>4.更新预先序列</h3><p>遍历训练集，计算当前训练集数据 X_train<del>i</del> 与待分数据 X_test<del>j</del> 的距离 L ，比较 L 与预先的最大距离 LMax 大小，若大于，直接进入下一训练集数据 X_train<del>i+1</del> ，若小于，将 LMax 对应的序列数据替换成 X_train<del>i</del> 。<br><strong>在需要替换时，其实还需要一步判断，在构建预先序列时，K个随机值构成的 idList 可能已经包含了当前训练集数据 X_train_i 的索引值即 i ，所以如果替换元素的话，近邻队列不就出现1或多个重复的元素了吗？，那么分类应该会有误差</strong>。参考百科中的第 6 步，似乎没有考虑到。<br><code>解决上文提到的 “ 判断 ” </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">    index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">    self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">    distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br></pre></td></tr></table></figure>

<p><code>算法当前步骤所有代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">distList = self.get_deftDist(tp) <span class="comment"># 获取此时测试数据x_new[i]与预先序列的距离</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train)):</span><br><span class="line">    Lmax = <span class="built_in">max</span>(distList)</span><br><span class="line">    L = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train[j])):</span><br><span class="line">        L += (tp[k]-self.x_train[j][k])**<span class="number">2</span> <span class="comment"># 遍历训练集，计算当前x_new[i]训练集与x_train[j]的距离</span></span><br><span class="line">    L = math.sqrt(L)</span><br><span class="line">    <span class="keyword">if</span> L &gt;= Lmax:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 若当前所得距离大于预先序列距离的最大值，进入下一个训练数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 更新预先序列中的距离和对应训练数据的id</span></span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">            index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">            self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">            distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br></pre></td></tr></table></figure>

<h3 id="5-获取测试集所属类"><a href="#5-获取测试集所属类" class="headerlink" title="5.获取测试集所属类"></a>5.获取测试集所属类</h3><p>遍历最后的近邻序列，选择出其中多数类，得出测试数据集的所需类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)): <span class="comment"># 遍历预先序列中，计算其中的多数类，判断测试数据属于哪类</span></span><br><span class="line">        indI = self.idList[m]</span><br><span class="line">        targetI = self.y_train[indI]</span><br><span class="line">        <span class="keyword">if</span> targetI == <span class="number">0</span>:</span><br><span class="line">            flag[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> targetI == <span class="number">1</span>:</span><br><span class="line">            flag[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> targetI == <span class="number">2</span>:</span><br><span class="line">            flag[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">        <span class="comment">#print(flag)</span></span><br><span class="line">    <span class="comment">#print(&#x27;测试数据所属类: &#x27;, flag.index(max(flag)))</span></span><br><span class="line">    targetList.append(flag.index(<span class="built_in">max</span>(flag))) <span class="comment"># 返回第一个极大值的索引值</span></span><br></pre></td></tr></table></figure>

<h3 id="预测模型的精准度"><a href="#预测模型的精准度" class="headerlink" title="预测模型的精准度"></a>预测模型的精准度</h3><p>除了上述knn算法的五个步骤外，还额外添加了计算模型的精确值的方法 score() 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, y_pre, y_test</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算精确值&#x27;&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    scoreList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>], <span class="built_in">zip</span>(y_pre, y_test)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> scoreList:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    score = count/<span class="built_in">len</span>(scoreList)</span><br><span class="line">    <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>算法结构是<strong>仿照 KNeighborsClassifier</strong>的使用过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">31</span>) <span class="comment">#设定近邻指标</span></span><br><span class="line"></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pre = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">score = knn.score(X_test, y_test)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>KNeighborsClassifier</th>
<th>MyKNN</th>
<th>MykNN的方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>–init–()</td>
<td>–init–()</td>
<td>设定近邻个数</td>
</tr>
<tr>
<td>fit()</td>
<td>get_trainData()</td>
<td>获取训练集数据</td>
</tr>
<tr>
<td>predict()</td>
<td>predict()</td>
<td>产生预测模型</td>
</tr>
<tr>
<td>score()</td>
<td>score()</td>
<td>计算精确度</td>
</tr>
</tbody></table>
<p><code>完整knn代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyKNN</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_neighbors</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;指定近邻个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.n_neighbors = n_neighbors <span class="comment"># 近邻数</span></span><br><span class="line">        <span class="comment"># self.x_new = [] # 预测数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x_new</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;预测模型, 更新近邻序列和得出测试数据所属类&#x27;&#x27;&#x27;</span></span><br><span class="line">        targetList = [] <span class="comment"># 存储预测数据的预测所属类</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_new)):</span><br><span class="line">            tp = x_new[i]</span><br><span class="line">            <span class="comment">#print(tp)</span></span><br><span class="line">            distList = self.get_deftDist(tp) <span class="comment"># 获取此时测试数据x_new[i]与预先序列的距离</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train)):</span><br><span class="line">                Lmax = <span class="built_in">max</span>(distList)</span><br><span class="line">                L = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.x_train[j])):</span><br><span class="line">                    L += (tp[k]-self.x_train[j][k])**<span class="number">2</span> <span class="comment"># 遍历训练集，计算当前x_new[i]训练集与x_train[j]的距离</span></span><br><span class="line">                L = math.sqrt(L)</span><br><span class="line">                <span class="keyword">if</span> L &gt;= Lmax:</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># 若当前所得距离大于预先序列距离的最大值，进入下一个训练数据</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 更新预先序列中的距离和对应训练数据的id</span></span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.idList:</span><br><span class="line">                        index = distList.index(Lmax) <span class="comment"># 获取最大预先距离的索引</span></span><br><span class="line">                        self.idList[index] = j <span class="comment"># 换为当前训练数据的id</span></span><br><span class="line">                        distList[index] = L <span class="comment"># 更新最大预先距离</span></span><br><span class="line">                <span class="comment">#distList[i].append(L)</span></span><br><span class="line">        <span class="comment">#return sorted(distList)</span></span><br><span class="line">            flag = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)): <span class="comment"># 遍历预先序列中，计算其中的多数类，判断测试数据属于哪类</span></span><br><span class="line">                indI = self.idList[m]</span><br><span class="line">                targetI = self.y_train[indI]</span><br><span class="line">                <span class="keyword">if</span> targetI == <span class="number">0</span>:</span><br><span class="line">                    flag[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> targetI == <span class="number">1</span>:</span><br><span class="line">                    flag[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> targetI == <span class="number">2</span>:</span><br><span class="line">                    flag[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment">#print(flag)</span></span><br><span class="line">            <span class="comment">#print(&#x27;测试数据所属类: &#x27;, flag.index(max(flag)))</span></span><br><span class="line">            targetList.append(flag.index(<span class="built_in">max</span>(flag))) <span class="comment"># 返回第一个极大值的索引值</span></span><br><span class="line">            <span class="comment">#print(&#x27;the distance:\n&#123;&#125;&#x27;.format(self.distList))</span></span><br><span class="line">        <span class="keyword">return</span> targetList</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_trainData</span>(<span class="params">self, x_train, y_train</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取训练集数据&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.x_train = x_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line">        self.idList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x_train)), self.n_neighbors) <span class="string">&#x27;&#x27;&#x27; 获取空间大小为k的预先序列,k个随机的元             </span></span><br><span class="line"><span class="string">        组,k=n_neighbors&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#self.deftDic = &#123;&#x27;id&#x27;:self.idList, &#x27;distance&#x27;:self.distList, &#x27;target&#x27;:self.y_train&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_deftDist</span>(<span class="params">self, tp</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;计算测试数据与预先序列的距离&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">list</span> = [] <span class="comment"># 存放预测数据与预先序列的距离，列表含有k个距离</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        for i in range(len(self.x_new)):</span></span><br><span class="line"><span class="string">            tp = self.x_new[i]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.idList)):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            index = self.idList[j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tp)):</span><br><span class="line">                <span class="built_in">sum</span> += (tp[k]-self.x_train[index][k])**<span class="number">2</span> </span><br><span class="line">            <span class="built_in">sum</span> = math.sqrt(<span class="built_in">sum</span>)</span><br><span class="line">            <span class="built_in">list</span>.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, y_pre, y_test</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;计算精确值&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        scoreList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>], <span class="built_in">zip</span>(y_pre, y_test)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> scoreList:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        score = count/<span class="built_in">len</span>(scoreList)</span><br><span class="line">        <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"><span class="comment">#myDataset = &#123;&#x27;data&#x27;:[[2, 3, 0, 0], [3, 4, 0, 0], [4, 5, 0, 0], [5, 6, 0, 0]],</span></span><br><span class="line"><span class="comment">#             &#x27;target&#x27;:[2, 1, 0, 1]&#125;</span></span><br><span class="line"><span class="comment">#X_train, y_train = myDataset[&#x27;data&#x27;], myDataset[&#x27;target&#x27;]</span></span><br><span class="line"><span class="comment">#X_test = [[1, 2, 0, 0],[0, 0, 0, 0]]</span></span><br><span class="line"></span><br><span class="line">iris_dataset = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_dataset[<span class="string">&#x27;data&#x27;</span>], iris_dataset[<span class="string">&#x27;target&#x27;</span>], random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()      </span><br><span class="line"></span><br><span class="line">knn = MyKNN(n_neighbors=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">knn.get_trainData(X_train, y_train)</span><br><span class="line">y_pre = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Holding time: &#x27;</span>, time.time()-start) <span class="comment"># 输出KNN运行时间，时间效率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the kind of X_test:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(y_pre)) <span class="comment"># 输出测试数据的预测类别</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the score:&#123;:.2&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(y_pre, y_test))) <span class="comment"># 输出模型精准度</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/06/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/" data-id="clg4u0zfm0003ogaaakst6cvx" data-title="python实现KNN算法" class="article-share-link">Condividi</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/04/07/039keepalive/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuovi</strong>
      <div class="article-nav-title">
        
          039keepalive
        
      </div>
    </a>
  
  
    <a href="/2023/04/06/037-8%E5%A4%8D%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Vecchi</strong>
      <div class="article-nav-title">037-8复习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorie</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">百日博客计划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BE%E6%97%A5%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/%E4%BB%BF%E6%90%BA%E7%A8%8B%E7%BD%91%E7%AB%99/">仿携程网站</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-defineProperty/" rel="tag">Object.defineProperty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bind/" rel="tag">bind</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computed/" rel="tag">computed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data/" rel="tag">data()</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eventloop/" rel="tag">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hide/" rel="tag">hide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keep-alive/" rel="tag">keep-alive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/line-height/" rel="tag">line-height</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/new/" rel="tag">new</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/" rel="tag">position</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/" rel="tag">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot/" rel="tag">slot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this%E5%AF%B9%E8%B1%A1/" rel="tag">this对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/watch/" rel="tag">watch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/" rel="tag">居中对齐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" rel="tag">数据绑定</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag">生命周期</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" rel="tag">节流防抖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 16px;">CSS</a> <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JS/" style="font-size: 14px;">JS</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Object-defineProperty/" style="font-size: 10px;">Object.defineProperty</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/React/" style="font-size: 20px;">React</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Vue/" style="font-size: 18px;">Vue</a> <a href="/tags/bind/" style="font-size: 10px;">bind</a> <a href="/tags/computed/" style="font-size: 10px;">computed</a> <a href="/tags/data/" style="font-size: 10px;">data()</a> <a href="/tags/eventloop/" style="font-size: 10px;">eventloop</a> <a href="/tags/hexo/" style="font-size: 14px;">hexo</a> <a href="/tags/hide/" style="font-size: 10px;">hide</a> <a href="/tags/keep-alive/" style="font-size: 10px;">keep-alive</a> <a href="/tags/line-height/" style="font-size: 10px;">line-height</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/nextTick/" style="font-size: 10px;">nextTick</a> <a href="/tags/position/" style="font-size: 10px;">position</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/slot/" style="font-size: 10px;">slot</a> <a href="/tags/this%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">this对象</a> <a href="/tags/uniapp/" style="font-size: 14px;">uniapp</a> <a href="/tags/watch/" style="font-size: 10px;">watch</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 10px;">作用域</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/" style="font-size: 10px;">居中对齐</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">数据类型</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" style="font-size: 10px;">数据绑定</a> <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="font-size: 10px;">生命周期</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 12px;">网络</a> <a href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" style="font-size: 10px;">节流防抖</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size: 10px;">闭包</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 18px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivio</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Post Recenti</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/13/065Promise%E4%B8%8Easync%E3%80%81await/">065Promise与async、await</a>
          </li>
        
          <li>
            <a href="/2023/05/12/064Promise1/">064Promise1</a>
          </li>
        
          <li>
            <a href="/2023/05/11/063JS%E9%AB%98%E9%98%B6eventloop/">063JS高阶eventloop</a>
          </li>
        
          <li>
            <a href="/2023/05/10/062CSS%E5%93%8D%E5%BA%94%E5%BC%8F/">062CSS响应式</a>
          </li>
        
          <li>
            <a href="/2023/05/09/061%E9%87%8D%E5%90%AF%E7%99%BE%E6%97%A5%E9%A1%B9%E7%9B%AE/">061重启百日项目</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 yh0ng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>